const http = require("http");
const https = require("https");
const WebSocket = require("ws");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const { exec } = require("child_process");

// ===== CONFIG =====
const PORT_HTTP = 8080;
const PORT_HTTPS = 8443;
const DATA = "./data";
const MSGS = "./data/messages";
const USERS_FILE = DATA + "/users.json";
const ROOMS_FILE = DATA + "/rooms.json";
const ADMIN_FILE = DATA + "/admin.json";
const MAX_PUBLIC_MSGS = 500;
const MAX_PRIVATE_MSGS = 500;
const DELETE_COUNT = 400;
const SSL_DIR = "./ssl";

// ===== INIT FILES & FOLDERS =====
function createFileIfNotExists(filePath, defaultData) {
Â Â if (!fs.existsSync(filePath)) {
Â Â Â Â fs.writeFileSync(filePath, defaultData);
Â Â Â Â console.log(`âœ… Created file: ${filePath}`);
Â Â }
}

function createFolderIfNotExists(folderPath) {
Â Â if (!fs.existsSync(folderPath)) {
Â Â Â Â fs.mkdirSync(folderPath, { recursive: true });
Â Â Â Â console.log(`ðŸ“ Created folder: ${folderPath}`);
Â Â }
}

createFolderIfNotExists(DATA);
createFolderIfNotExists(MSGS);
createFolderIfNotExists(SSL_DIR);

createFileIfNotExists(USERS_FILE, "{}");
createFileIfNotExists(ROOMS_FILE, "{}");
createFileIfNotExists(ADMIN_FILE, JSON.stringify({ password: null }, null, 2));

// ===== SELF-GENERATING HTTPS CERT =====
const keyPath = path.join(SSL_DIR, "key.pem");
const certPath = path.join(SSL_DIR, "cert.pem");

let sslOptions = { key: null, cert: null };
let httpsAvailable = false;

function generateSSL(cb) {
Â Â console.log("âš¡ Attempting to generate self-signed HTTPS certificate...");
Â Â exec(
Â Â Â Â `openssl req -x509 -newkey rsa:2048 -nodes -keyout ${keyPath} -out ${certPath} -days 365 -subj "/CN=localhost"`,
Â Â Â Â (err) => {
Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â console.warn("âš  HTTPS not available, falling back to HTTP only.", err);
Â Â Â Â Â Â Â Â httpsAvailable = false;
Â Â Â Â Â Â Â Â cb();
Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log("âœ… Self-signed HTTPS certificate created.");
Â Â Â Â Â Â Â Â sslOptions = {
Â Â Â Â Â Â Â Â Â Â key: fs.readFileSync(keyPath),
Â Â Â Â Â Â Â Â Â Â cert: fs.readFileSync(certPath),
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â httpsAvailable = true;
Â Â Â Â Â Â Â Â cb();
Â Â Â Â Â Â }
Â Â Â Â }
Â Â );
}

// ===== HELPERS =====
const readJSON = (f) => JSON.parse(fs.readFileSync(f));
const writeJSON = (f, d) => fs.writeFileSync(f, JSON.stringify(d, null, 2));
const deviceId = (req) =>
Â Â crypto
Â Â Â Â .createHash("sha256")
Â Â Â Â .update(req.socket.remoteAddress + req.headers["user-agent"])
Â Â Â Â .digest("hex");
const roomFile = (r) =>
Â Â MSGS + "/" + (r.startsWith("private_") ? r + ".json" : r === "public" ? "public.json" : `room_${r}.json`);
const loadMsgs = (r) => {
Â Â if (!fs.existsSync(roomFile(r))) fs.writeFileSync(roomFile(r), "[]");
Â Â return readJSON(roomFile(r));
};
const saveMsgs = (r, msgs) => {
Â Â const limit = r.startsWith("private_") ? MAX_PRIVATE_MSGS : MAX_PUBLIC_MSGS;
Â Â if (msgs.length > limit) msgs = msgs.slice(-limit + (limit - DELETE_COUNT));
Â Â writeJSON(roomFile(r), msgs);
Â Â if (msgs.length % 50 === 0)
Â Â Â Â console.log(`ðŸ’¬ Room "${r}" reached ${msgs.length} messages`);
Â Â return msgs;
};

// ===== SERVERS =====
const httpServer = http.createServer((req, res) => {
Â Â const f = req.url === "/" ? "/index.html" : req.url;
Â Â if (f.startsWith("/admin-dashboard")) {
Â Â Â Â fs.readFile(path.join(__dirname, "admin-dashboard.html"), (e, d) => {
Â Â Â Â Â Â if (e) return res.end("404");
Â Â Â Â Â Â res.end(d);
Â Â Â Â });
Â Â Â Â return;
Â Â }
Â Â fs.readFile(path.join(__dirname, f), (e, d) => {
Â Â Â Â if (e) return res.end("404");
Â Â Â Â res.end(d);
Â Â });
});

let httpsServer = null;

// ===== WEBSOCKET =====
const wss = new WebSocket.Server({ server: httpServer });
const sockets = new Map();

function emitOnlineUsers() {
Â Â const data = JSON.stringify({ type: "online-users", count: wss.clients.size });
Â Â wss.clients.forEach((c) => {
Â Â Â Â if (c.readyState === WebSocket.OPEN) c.send(data);
Â Â });
}

// ===== ADMIN =====
let adminData = readJSON(ADMIN_FILE);

// ===== CONNECTION LOGIC =====
function setupWebSocket() {
Â Â wss.on("connection", (ws, req) => {
Â Â Â Â const dId = deviceId(req);
Â Â Â Â const users = readJSON(USERS_FILE);
Â Â Â Â const rooms = readJSON(ROOMS_FILE);

Â Â Â Â if (!users[dId]) {
Â Â Â Â Â Â users[dId] = {
Â Â Â Â Â Â Â Â id: crypto.randomUUID(),
Â Â Â Â Â Â Â Â name: null,
Â Â Â Â Â Â Â Â nameChanges: 0,
Â Â Â Â Â Â Â Â admin: Object.keys(users).length === 0,
Â Â Â Â Â Â Â Â banned: false,
Â Â Â Â Â Â Â Â muted: false,
Â Â Â Â Â Â Â Â adminLoggedIn: Object.keys(users).length === 0,
Â Â Â Â Â Â };
Â Â Â Â Â Â writeJSON(USERS_FILE, users);
Â Â Â Â Â Â console.log(`ðŸ†• New user created: ${dId}`);
Â Â Â Â }

Â Â Â Â const user = users[dId];
Â Â Â Â if (user.banned) return ws.close();
Â Â Â Â sockets.set(ws, dId);
Â Â Â Â ws.send(JSON.stringify({ type: "me", user }));
Â Â Â Â emitOnlineUsers();

Â Â Â Â ws.on("message", (raw) => {
Â Â Â Â Â Â let data;
Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â data = JSON.parse(raw);
Â Â Â Â Â Â } catch {
Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }
Â Â Â Â Â Â const users = readJSON(USERS_FILE);
Â Â Â Â Â Â const rooms = readJSON(ROOMS_FILE);
Â Â Â Â Â Â const user = users[dId];

Â Â Â Â Â Â // ---- USERNAME ----
Â Â Â Â Â Â if (data.type === "set-name") {
Â Â Â Â Â Â Â Â if (user.name && user.nameChanges >= 1) return;
Â Â Â Â Â Â Â Â user.name = data.name;
Â Â Â Â Â Â Â Â user.nameChanges++;
Â Â Â Â Â Â Â Â writeJSON(USERS_FILE, users);
Â Â Â Â Â Â }

Â Â Â Â Â Â // ---- CREATE ROOM ----
Â Â Â Â Â Â if (data.type === "create-room") {
Â Â Â Â Â Â Â Â if (!rooms[data.room]) {
Â Â Â Â Â Â Â Â Â Â rooms[data.room] = { password: data.password || null };
Â Â Â Â Â Â Â Â Â Â writeJSON(ROOMS_FILE, rooms);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }

Â Â Â Â Â Â // ---- PUBLIC CHAT ----
Â Â Â Â Â Â if (data.type === "chat") {
Â Â Â Â Â Â Â Â if (!user.name || user.muted) return;
Â Â Â Â Â Â Â Â const room = data.room || "public";
Â Â Â Â Â Â Â Â if (rooms[room]?.password && rooms[room].password !== data.password) return;
Â Â Â Â Â Â Â Â let msgs = loadMsgs(room);
Â Â Â Â Â Â Â Â msgs.push({ user: user.name, text: data.text, time: Date.now() });
Â Â Â Â Â Â Â Â msgs = saveMsgs(room, msgs);
Â Â Â Â Â Â Â Â wss.clients.forEach((c) => {
Â Â Â Â Â Â Â Â Â Â if (c.readyState === WebSocket.OPEN)
Â Â Â Â Â Â Â Â Â Â Â Â c.send(JSON.stringify({ type: "chat", room, msg: msgs.at(-1) }));
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â }

Â Â Â Â Â Â // ---- PRIVATE 1:1 CHAT ----
Â Â Â Â Â Â if (data.type === "private-chat") {
Â Â Â Â Â Â Â Â const targetId = Object.keys(users).find((id) => users[id].id === data.toId);
Â Â Â Â Â Â Â Â if (!targetId || !users[targetId].name) return;
Â Â Â Â Â Â Â Â const room = `private_${[dId, targetId].sort().join("_")}`;
Â Â Â Â Â Â Â Â let msgs = loadMsgs(room);
Â Â Â Â Â Â Â Â msgs.push({ user: user.name, text: data.text, time: Date.now() });
Â Â Â Â Â Â Â Â msgs = saveMsgs(room, msgs);
Â Â Â Â Â Â Â Â [dId, targetId].forEach((id) => {
Â Â Â Â Â Â Â Â Â Â sockets.forEach((sid, ws) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (sid === id && ws.readyState === WebSocket.OPEN)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â ws.send(JSON.stringify({ type: "private-chat", room, msg: msgs.at(-1) }));
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â }

Â Â Â Â Â Â // ---- REACTIONS / LIKES ----
Â Â Â Â Â Â if (data.type === "react") {
Â Â Â Â Â Â Â Â const room = data.room || "public";
Â Â Â Â Â Â Â Â const msgs = loadMsgs(room);
Â Â Â Â Â Â Â Â const msg = msgs.find((m) => m.time === data.time && m.user === data.user);
Â Â Â Â Â Â Â Â if (msg) {
Â Â Â Â Â Â Â Â Â Â msg.reactions = msg.reactions || {};
Â Â Â Â Â Â Â Â Â Â msg.reactions[data.emoji] = msg.reactions[data.emoji] || 0;
Â Â Â Â Â Â Â Â Â Â msg.reactions[data.emoji]++;
Â Â Â Â Â Â Â Â Â Â saveMsgs(room, msgs);
Â Â Â Â Â Â Â Â Â Â wss.clients.forEach((c) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (c.readyState === WebSocket.OPEN)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â c.send(JSON.stringify({ type: "chat-update", room, msg }));
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }

Â Â Â Â Â Â // ---- HISTORY ----
Â Â Â Â Â Â if (data.type === "history")
Â Â Â Â Â Â Â Â ws.send(
Â Â Â Â Â Â Â Â Â Â JSON.stringify({ type: "history", room: data.room, messages: loadMsgs(data.room) })
Â Â Â Â Â Â Â Â );

Â Â Â Â Â Â // ---- ADMIN LOGIN ----
Â Â Â Â Â Â if (data.type === "admin-login") {
Â Â Â Â Â Â Â Â if (!adminData.password) return;
Â Â Â Â Â Â Â Â const hash = crypto.createHash("sha256").update(data.password).digest("hex");
Â Â Â Â Â Â Â Â if (hash === adminData.password) {
Â Â Â Â Â Â Â Â Â Â users[dId].admin = true;
Â Â Â Â Â Â Â Â Â Â users[dId].adminLoggedIn = true;
Â Â Â Â Â Â Â Â Â Â writeJSON(USERS_FILE, users);
Â Â Â Â Â Â Â Â Â Â ws.send(JSON.stringify({ type: "system", msg: "Admin login successful ðŸ˜Ž" }));
Â Â Â Â Â Â Â Â } else ws.send(JSON.stringify({ type: "system", msg: "âŒ Wrong admin password" }));
Â Â Â Â Â Â }

Â Â Â Â Â Â // ---- ADMIN ACTIONS + DASHBOARD ----
Â Â Â Â Â Â if (user.admin && user.adminLoggedIn) {
Â Â Â Â Â Â Â Â if (data.type === "ban" && users[data.target]) {
Â Â Â Â Â Â Â Â Â Â users[data.target].banned = true;
Â Â Â Â Â Â Â Â Â Â writeJSON(USERS_FILE, users);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (data.type === "mute" && users[data.target]) {
Â Â Â Â Â Â Â Â Â Â users[data.target].muted = true;
Â Â Â Â Â Â Â Â Â Â writeJSON(USERS_FILE, users);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (data.type === "unmute" && users[data.target]) {
Â Â Â Â Â Â Â Â Â Â users[data.target].muted = false;
Â Â Â Â Â Â Â Â Â Â writeJSON(USERS_FILE, users);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (data.type === "delete-room" && rooms[data.room]) {
Â Â Â Â Â Â Â Â Â Â delete rooms[data.room];
Â Â Â Â Â Â Â Â Â Â writeJSON(ROOMS_FILE, rooms);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (data.type === "dashboard") {
Â Â Â Â Â Â Â Â Â Â ws.send(
Â Â Â Â Â Â Â Â Â Â Â Â JSON.stringify({
Â Â Â Â Â Â Â Â Â Â Â Â Â Â type: "dashboard",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â onlineUsers: wss.clients.size,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â totalUsers: Object.keys(users).length,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â rooms: Object.keys(rooms),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â users: Object.values(users),
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â ws.on("close", () => {
Â Â Â Â Â Â sockets.delete(ws);
Â Â Â Â Â Â emitOnlineUsers();
Â Â Â Â });
Â Â });
}

// ===== START SERVERS =====
function startServers() {
Â Â httpServer.listen(PORT_HTTP, () =>
Â Â Â Â console.log(`ðŸ”¥ CHAT SERVER RUNNING @ http://localhost:${PORT_HTTP} (HTTP)`)
Â Â );
Â Â if (httpsAvailable) {
Â Â Â Â httpsServer = https.createServer(sslOptions, httpServer.listeners("request")[0]);
Â Â Â Â httpsServer.listen(PORT_HTTPS, () =>
Â Â Â Â Â Â console.log(`ðŸ”’ CHAT SERVER RUNNING @ https://localhost:${PORT_HTTPS} (HTTPS + WSS)`)
Â Â Â Â );
Â Â Â Â wss.options.server = httpsServer;
Â Â }
Â Â console.log("âš¡ Ngrok removed, Termux/ARM environment ready");
Â Â setupWebSocket();
}

// ===== CHECK HTTPS =====
if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
Â Â sslOptions = { key: fs.readFileSync(keyPath), cert: fs.readFileSync(certPath) };
Â Â httpsAvailable = true;
Â Â startServers();
} else {
Â Â generateSSL(startServers);
}
